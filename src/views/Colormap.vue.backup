<template>
<div>
	<v-card flat style="margin-top: 400px; height: 500px;">
		<!-- <v-btn-toggle v-model="calendar_mode" mandatory floating style="padding-left: 20px;position:fixed">
			<v-btn flat>
				<v-icon>info</v-icon>
			</v-btn>
			<v-btn flat>
				<v-icon>select_all</v-icon>
			</v-btn>
		</v-btn-toggle> -->
		<div style="padding-left: 20px;position:fixed">
			<v-btn small flat mandatory icon @click.prevent="showNormal">
				<v-icon>subject</v-icon>
			</v-btn>
			<v-btn small flat mandatory icon @click.prevent="showError">
				<v-icon>error</v-icon>
			</v-btn>
			<v-btn small flat mandatory icon @click.prevent="selectMask">
				<v-icon>settings_ethernet</v-icon>
			</v-btn>
			<!-- <v-btn small flat mandatory icon @click.prevent="fresh">
				<v-icon>autorenew</v-icon>
			</v-btn> -->
		</div>
		<Calendar ref="cal" style="padding-top: 30px;" @loaded="onCalendarLoaded"></Calendar>
	</v-card>
	<v-card style="position: fixed; top:0; left: 300px; right: 0" :class="{ expandToolbar: myState}">
		<v-container fluid style="padding-top: 5px; padding-bottom: 0">
			<v-layout column fill-height>
				<v-flex d-flex>
					<v-layout row fill-height ref="ruler">
						<v-flex d-flex xs3 style="max-width: 270px; min-width: 256px">
							<v-layout row fill-height>
								<v-flex d-flex>
									<v-menu
									ref="startDateMenu"
									:close-on-content-click="false"
									v-model="startDateMenu"
									:nudge-right="40"
									:return-value.sync="startDate"
									lazy
									transition="scale-transition"
									offset-y
									full-width
									min-width="290px"
									
									>
										<v-text-field
										slot="activator"
										v-model="startDate"
										label="Start Date"
										prepend-icon="event"
										readonly
										></v-text-field>
										<v-date-picker v-model="startDate" 
										@input="onStartDatePicked" 
										:min="minDate"
										:max="maxDate"></v-date-picker>

									</v-menu>
								</v-flex>
								<v-flex d-flex>
									<v-menu
									ref="endDateMenu"
									:close-on-content-click="false"
									v-model="endDateMenu"
									:nudge-right="40"
									:return-value.sync="endDate"
									lazy
									transition="scale-transition"
									offset-y
									full-width
									min-width="290px"
									>
										<v-text-field
										slot="activator"
										v-model="endDate"
										label="End Date"
										prepend-icon="event"
										readonly
										></v-text-field>
										<v-date-picker v-model="endDate" @input="onEndDatePicked"
										:min="minDate"
										:max="maxDate"></v-date-picker>

									</v-menu>
								</v-flex>
							</v-layout>
						</v-flex>
						<v-flex d-flex ref="sliderctn">
							<Slider ref="sld"></Slider>
						</v-flex>
					</v-layout>
				</v-flex>
				<v-flex d-flex>
					<v-layout row fill-height>
						<v-flex d-flex xs3 style="max-width: 270px; min-width: 256px">
							<v-card flat style="min-width: 256px;max-width: 256px; margin: 0 auto;">
								<colormap ref="cm" @loaded="onColormapLoaded"></colormap>
								<v-card-actions style="max-height: 60px;">
									<v-slider
										v-model="lineAlpha"
										thumb-label
										value="30"
									></v-slider>
									<v-spacer></v-spacer>
									<v-btn flat @click="$refs.cm.resetZoom()">
										<v-icon>refresh</v-icon>reset
									</v-btn>
								</v-card-actions>
							</v-card>
						</v-flex>
						<v-flex d-flex>
							<v-card flat>
							<parallel ref="pcp" @loaded="onParallelLoaded"></parallel>
							</v-card>
						</v-flex>
					</v-layout>
				</v-flex>

			</v-layout>
		</v-container>
	</v-card>
</div>
</template>

<script>
const EventBus = {

}
import { mapGetters } from 'vuex'
import Colormap from '@/components/Colormap.vue'
import Calendar from '@/components/Calendar.vue'
import Parallel from '@/components/Parallel.vue'
import Slider from '@/components/Slider.vue'

export default {
	components: {
		Colormap,
		Calendar,
		Parallel,
		Slider,
	},
	data: () => ({
		calendar_mode: 0,

		startDate: null,
		startDateMenu: false,
		endDate: null,
		endDateMenu: false,

		minDate: null,
		maxDate: null,
		dotAlpha: 100,
		lineAlpha:30,
		init: {
			cal: false,
			cm: false,
			pcp: false,
			me: false,
		},

		firstLoad: true,
	}),
	watch: {
		dotAlpha() {
			this.changeAlpha()
		},
		lineAlpha(){
			this.changeAlpha()
		},
		myState() {
			// not sure if this is costly
			this.handleResize()
		},
		calendar_mode() {
			this.changeCalendarMode()
		}
	},
	methods: {
		fresh(){
			console.log("fresh")
		},
		showError(){
			let vm = this
			console.log("showError")
			vm.eventBus.cm.__changeColor(true)
		},
		showNormal(){
			let vm = this
			console.log("showNormal")
			vm.eventBus.cm.__changeColor(false)
		},
		selectMask(){
			let vm = this
			console.log("mask mode")
			vm.eventBus.cm.maskSelect()
		},
		changeCalendarMode() {
			var vm = this
			let mode = ['tooltip', 'box_select', 'zoom'][vm.calendar_mode]
			vm.eventBus.cal.switchMode(mode)
		},
		onStartDatePicked() {
			var vm = this
			vm.$refs.startDateMenu.save(vm.startDate)
			vm.changeDate()
		},

		onEndDatePicked() {
			var vm = this
			vm.$refs.endDateMenu.save(vm.endDate)
			vm.changeDate()
		},

		changeDate() {
			var vm = this
			let sd = vm.$moment.utc(vm.startDate)
			let ed = vm.$moment.utc(vm.endDate)
			if (sd > ed) {
				return
			}
			sd = sd.format('YYYY-MM-DD') + " 00:00:00"
			ed = ed.format('YYYY-MM-DD') + " 00:00:00"
			vm.loadData(vm.eventBus.zoomHistory[vm.eventBus.zoomHistory.length-1].interval, sd, ed)
		},

		allInited() {
			var vm = this
			return vm.init.cal && vm.init.cm && vm.init.me && vm.init.pcp
		},

		onCalendarLoaded() {
			var vm = this
			vm.init.cal = true
		},

		onColormapLoaded() {
			var vm = this
			vm.init.cm = true
		},

		onParallelLoaded() {
			var vm = this
			vm.init.pcp = true
		},

		onDataLoaded(response) {
			var vm = this
			vm.response = response
			console.log(response.data)
			vm.eventBus.mask = response.data.mask
			vm.eventBus.columns = response.data.columns
			vm.eventBus.std = response.data.std

			let date_idx = response.data.columns.indexOf('date')
			vm.eventBus.date_idx = date_idx
			vm.eventBus.data = response.data.data.map((d, di) => {
				return {
					mask: vm.eventBus.mask[di][1],
					raw: d,
					datetime: vm.$moment.utc(d[date_idx])
				}
			})

			let sd = vm.$moment.utc(response.data.data[0][date_idx])
			let ed = vm.$moment.utc(response.data.data[response.data.data.length-1][date_idx])
			vm.startDate = sd.format('YYYY-MM-DD')
			vm.endDate = ed.format('YYYY-MM-DD')

			if (vm.firstLoad) {
				vm.firstLoad = false
				vm.minDate = vm.startDate
				vm.maxDate = vm.endDate
			}

			vm.eventBus.startDate = vm.$moment.utc(vm.startDate)
			vm.eventBus.endDate = vm.$moment.utc(vm.endDate)

			vm.init.me = true
		},
		// eslint-disable-next-line
		loadData(interval, startDate, endDate) {
			var vm = this

			vm.eventBus.zoomHistory.push({
				calLevel: vm.eventBus.calLevel,
				interval,
				startDate,
				endDate
			})

			vm.init.me = false
			vm.$refs.sld.clearData()
			if (vm.init.cm) {
				vm.$refs.cm.clearData()
			}
			if (vm.init.cal) {
				vm.$refs.cal.clearData()
			}
			if (vm.init.pcp) {
				vm.$refs.pcp.clearData()
			}

			let param = {
				interval
			}

			if (startDate) {
				param.start_date = startDate
			}

			if (endDate) {
				param.end_date = endDate
			}
			vm.$axios.post(vm.$api + '/model/latent', param)
			.then(vm.onDataLoaded)
			.catch(error => {
				window.error = error
				console.log(error)
			})

			vm.checkInit()
		},

		checkInit() {
			var vm = this
			if (vm.allInited()) {
				vm.$refs.pcp.updateCols()
				vm.$refs.cal.updateData()
				vm.$refs.cm.updateData()
				vm.$refs.sld.updateData()
				vm.handleResize()
			} else {
				setTimeout(vm.checkInit, 500)
			}
		},

		season() {
			// return this.seasons[val]
		},

		changeAlpha() {
			this.$refs.pcp.changeAlpha(this.lineAlpha / 100)
		},

		handleResize() {
			var vm = this
			setTimeout(function() {
				let mx_width = vm.$refs.ruler.clientWidth - 256
				vm.$refs.pcp.maxwidth = mx_width
				vm.$refs.pcp.handleResize()
				vm.$refs.sld.maxwidth = mx_width
				vm.$refs.sld.handleResize()
			}, 100) // wait for potential animation
		}

	},
	computed: {
		...mapGetters({
			myState: 'getMenuDrawer'
		})
	},
	mounted() {
		var vm = this;
		window.vm = vm
		vm.eventBus = EventBus
		vm.eventBus.zoomHistory = []

		EventBus.root = vm
		EventBus.cal = vm.$refs.cal
		EventBus.cm = vm.$refs.cm
		EventBus.pcp = vm.$refs.pcp
		EventBus.sld = vm.$refs.sld
		vm.$refs.cal.eventBus = EventBus
		vm.$refs.cm.eventBus = EventBus
		vm.$refs.pcp.eventBus = EventBus
		vm.$refs.sld.eventBus = EventBus

		// init loading here
		vm.changeCalendarMode()
		// vm.eventBus.calLevel = 'month'
		// vm.loadData('2 hour', "2017-01-01 00:00:00", "2017-12-31 00:00:00")
		vm.eventBus.calLevel = 'year'
		vm.loadData('1 day',)

		window.addEventListener('resize', vm.handleResize)
		vm.handleResize()
	},
	beforeDestroy() {
		var vm = this
		window.removeEventListener('resize', vm.handleResize)
	}
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
.expandToolbar {
	left: 80px !important;
}
#Alpha{
    transform: translate(-50px,130px)rotate(270deg);
    display: none;
}
</style>
